function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/*
 * @Author: moyee
 * @Date: 2019-07-30 12:10:26
 * @LastEditors: moyee
 * @LastEditTime: 2019-08-23 11:44:32
 * @Description: Group Controller
 */
var _require = require('lodash'),
    merge = _require.merge,
    isString = _require.isString;

var CustomGroup =
/*#__PURE__*/
function () {
  var _proto = CustomGroup.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    return {
      "default": {
        lineWidth: 1,
        stroke: '#A3B1BF',
        radius: 10,
        lineDash: [5, 5],
        strokeOpacity: 0.9,
        fill: '#F3F9FF',
        fillOpacity: 0.8,
        opacity: 0.8
      },
      hover: {
        stroke: '#faad14',
        fill: '#ffe58f',
        fillOpacity: 0.3,
        opacity: 0.3,
        lineWidth: 3
      },
      // 收起状态样式
      collapseStyle: {
        r: 30,
        lineDash: [5, 5],
        stroke: '#ffa39e',
        lineWidth: 3,
        fill: '#ffccc7'
      },
      icon: 'https://gw.alipayobjects.com/zos/rmsportal/MXXetJAxlqrbisIuZxDO.svg',
      text: {
        text: '新建群组',
        stroke: '#444'
      },
      operatorBtn: {
        collapse: {
          img: 'https://gw.alipayobjects.com/zos/rmsportal/uZVdwjJGqDooqKLKtvGA.svg',
          width: 16,
          height: 16
        },
        expand: {
          width: 16,
          height: 16,
          img: 'https://gw.alipayobjects.com/zos/rmsportal/MXXetJAxlqrbisIuZxDO.svg'
        }
      },
      visible: false
    };
  };

  function CustomGroup(graph) {
    // const { cfg = {} } = options;
    this.graph = graph;
    window.graph = graph;
    this.styles = this.getDefaultCfg(); // 创建的群组集合

    this.customGroup = {}; // 群组初始位置集合

    this.groupOriginBBox = {};
    this.delegateInGroup = {};
  }
  /**
   * 生成群组
   * @param {string} groupId 群组ID
   * @param {array} nodes 群组中的节点集合
   * @param {string} type 群组类型，默认为circle，支持rect
   * @param {number} zIndex 群组层级，默认为0
   * @memberof ItemGroup
   */


  _proto.create = function create(groupId, nodes, type, zIndex) {
    if (type === void 0) {
      type = 'circle';
    }

    if (zIndex === void 0) {
      zIndex = 0;
    }

    var graph = this.graph;
    var customGroup = graph.get('customGroup');
    var nodeGroup = customGroup.addGroup({
      id: groupId,
      zIndex: zIndex
    });
    var autoPaint = graph.get('autoPaint');
    graph.setAutoPaint(false);
    var defaultStyle = this.styles["default"]; // 计算群组左上角左边、宽度、高度及x轴方向上的最大值

    var _this$calculationGrou = this.calculationGroupPosition(nodes),
        x = _this$calculationGrou.x,
        y = _this$calculationGrou.y,
        width = _this$calculationGrou.width,
        height = _this$calculationGrou.height,
        maxX = _this$calculationGrou.maxX;

    var groupBBox = graph.get('groupBBoxs');
    groupBBox[groupId] = {
      x: x,
      y: y,
      width: width,
      height: height,
      maxX: maxX
    }; // step 1：绘制群组外框

    var keyShape = null;

    if (type === 'circle') {
      var r = width > height ? width / 2 : height / 2;
      var cx = (width + 2 * x) / 2;
      var cy = (height + 2 * y) / 2;
      keyShape = nodeGroup.addShape('circle', {
        attrs: _extends({}, defaultStyle, {
          x: cx,
          y: cy,
          r: r + nodes.length * 10
        }),
        capture: true,
        zIndex: zIndex,
        groupId: groupId
      }); // 更新群组及属性样式

      this.setDeletageGroupByStyle(groupId, nodeGroup, {
        width: width,
        height: height,
        x: cx,
        y: cy,
        r: r
      });
    } else {
      keyShape = nodeGroup.addShape('rect', {
        attrs: _extends({}, defaultStyle, {
          x: x,
          y: y,
          width: width,
          height: height
        }),
        capture: true,
        zIndex: zIndex,
        groupId: groupId
      }); // 更新群组及属性样式

      this.setDeletageGroupByStyle(groupId, nodeGroup, {
        width: width,
        height: height,
        x: x,
        y: y,
        btnOffset: maxX - 3
      });
    }

    nodeGroup.set('keyShape', keyShape);
    this.setGroupOriginBBox(groupId, keyShape.getBBox());
    graph.setAutoPaint(autoPaint);
    graph.paint();
  }
  /**
   * 修改Group样式
   * @param {Item} keyShape 群组的keyShape
   * @param {Object | String} style 样式
   */
  ;

  _proto.setGroupStyle = function setGroupStyle(keyShape, style) {
    if (!keyShape || keyShape.get('destroyed')) {
      return;
    }

    var styles = {};
    var _this$styles = this.styles,
        hoverStyle = _this$styles.hover,
        defaultStyle = _this$styles["default"];

    if (isString(style)) {
      if (style === 'default') {
        styles = merge({}, defaultStyle);
      } else if (style === 'hover') {
        styles = merge({}, hoverStyle);
      }
    } else {
      styles = merge({}, defaultStyle, style);
    }

    for (var s in styles) {
      keyShape.attr(s, styles[s]);
    }
  }
  /**
   * 根据GroupID计算群组位置，包括左上角左边及宽度和高度
   *
   * @param {object} nodes 符合条件的node集合：选中的node或具有同一个groupID的node
   * @return {object} 根据节点计算出来的包围盒坐标
   * @memberof ItemGroup
   */
  ;

  _proto.calculationGroupPosition = function calculationGroupPosition(nodes) {
    var graph = this.graph;
    var minx = [];
    var maxx = [];
    var miny = [];
    var maxy = []; // 获取已节点的所有最大最小x y值

    for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var id = _ref;
      var element = isString(id) ? graph.findById(id) : id;
      var bbox = element.getBBox();
      var _minX = bbox.minX,
          _minY = bbox.minY,
          _maxX = bbox.maxX,
          _maxY = bbox.maxY;
      minx.push(_minX);
      miny.push(_minY);
      maxx.push(_maxX);
      maxy.push(_maxY);
    } // 从上一步获取的数组中，筛选出最小和最大值


    var minX = Math.floor(Math.min.apply(Math, minx));
    var maxX = Math.floor(Math.max.apply(Math, maxx));
    var minY = Math.floor(Math.min.apply(Math, miny));
    var maxY = Math.floor(Math.max.apply(Math, maxy)); // const x = minX - 20;
    // const y = minY - 30;
    // const width = maxX - minX + 40;
    // const height = maxY - minY + 40;

    var x = minX;
    var y = minY;
    var width = maxX - minX;
    var height = maxY - minY;
    return {
      x: x,
      y: y,
      width: width,
      height: height,
      maxX: maxX
    };
  }
  /**
   * 拖动群组里面的节点，更新群组属性样式
   *
   * @param {string} groupId 群组ID
   * @return {boolean} null
   * @memberof ItemGroup
   */
  ;

  _proto.updateGroupStyleByNode = function updateGroupStyleByNode(groupId) {
    var graph = this.graph;
    var customGroup = graph.get('customGroup');
    var groupChild = customGroup.get('children');
    var currentGroup = groupChild.filter(function (child) {
      return child.get('id') === groupId;
    });
    var autoPaint = graph.get('autoPaint');
    graph.setAutoPaint(false); // 获取所有具有同一个groupID的节点，计算群组大小

    var nodes = graph.getNodes();
    var groupNodes = nodes.filter(function (node) {
      var currentModel = node.getModel();
      var gId = currentModel.groupId;
      return gId === groupId;
    });

    var _this$calculationGrou2 = this.calculationGroupPosition(groupNodes),
        x = _this$calculationGrou2.x,
        y = _this$calculationGrou2.y,
        width = _this$calculationGrou2.width,
        height = _this$calculationGrou2.height,
        maxX = _this$calculationGrou2.maxX;

    var current = currentGroup[0];

    if (!current) {
      return false;
    } // 更新rect属性样式


    var rect = current.getChildByIndex(0);
    rect.attr('x', x);
    rect.attr('y', y);
    rect.attr('width', width);
    rect.attr('height', height); // 更新群组图标属性样式

    var logoIcon = current.getChildByIndex(1);
    logoIcon.attr('x', x + 8);
    logoIcon.attr('y', y + 8); // 更新群组名称属性样式

    var text = current.getChildByIndex(2);
    text.attr('x', x + 35);
    text.attr('y', y + 21); // 更新收起和展开按钮属性样式

    var operatorBtn = current.getChildByIndex(3);
    operatorBtn.attr('x', maxX - 3);
    operatorBtn.attr('y', y + 8); // 更新群组及属性样式

    this.setDeletageGroupByStyle(groupId, current, {
      width: width,
      height: height,
      btnOffset: maxX - 3
    }); // 更新群组初始位置的bbox

    this.setGroupOriginBBox(groupId, rect.getBBox());
    graph.setAutoPaint(autoPaint);
    graph.paint();
  }
  /**
   * 设置群组初始位置的bbox，使用rect模拟
   *
   * @param {string} groupId 群组ID
   * @param {object} bbox 群组keyShape包围盒
   * @memberof ItemGroup
   */
  ;

  _proto.setGroupOriginBBox = function setGroupOriginBBox(groupId, bbox) {
    this.groupOriginBBox[groupId] = bbox;
  }
  /**
   * 获取群组初始位置及每次拖动后的位置
   *
   * @param {string} groupId 群组ID
   * @return {object} 指定groupId的原始BBox
   * @memberof ItemGroup
   */
  ;

  _proto.getGroupOriginBBox = function getGroupOriginBBox(groupId) {
    return this.groupOriginBBox[groupId];
  }
  /**
   * 设置群组对象及属性值
   *
   * @param {string} groupId 群组ID
   * @param {Group} deletage 群组元素
   * @param {object} property 属性值，里面包括width、height和maxX
   * @memberof ItemGroup
   */
  ;

  _proto.setDeletageGroupByStyle = function setDeletageGroupByStyle(groupId, deletage, property) {
    var width = property.width,
        height = property.height,
        x = property.x,
        y = property.y,
        r = property.r,
        btnOffset = property.btnOffset;
    var customGroupStyle = this.customGroup[groupId];

    if (!customGroupStyle) {
      // 首次赋值
      this.customGroup[groupId] = {
        nodeGroup: deletage,
        groupStyle: {
          width: width,
          height: height,
          x: x,
          y: y,
          r: r,
          btnOffset: btnOffset
        }
      };
    } else {
      // 更新时候merge配置项
      var groupStyle = customGroupStyle.groupStyle;
      var styles = merge({}, groupStyle, property);
      this.customGroup[groupId] = {
        nodeGroup: deletage,
        groupStyle: styles
      };
    }
  }
  /**
   * 根据群组ID获取群组及属性对象
   *
   * @param {string} groupId 群组ID
   * @return {Item} 群组
   * @memberof ItemGroup
   */
  ;

  _proto.getDeletageGroupById = function getDeletageGroupById(groupId) {
    return this.customGroup[groupId];
  }
  /**
   * 收起和展开群组
   * @param {string} groupId 群组ID
   */
  ;

  _proto.collapseExpandGroup = function collapseExpandGroup(groupId) {
    var customGroup = this.getDeletageGroupById(groupId);
    var nodeGroup = customGroup.nodeGroup;
    var hasHidden = nodeGroup.get('hasHidden'); // 该群组已经处于收起状态，需要展开

    if (hasHidden) {
      nodeGroup.set('hasHidden', false);
      this.expandGroup(groupId);
    } else {
      nodeGroup.set('hasHidden', true);
      this.collapseGroup(groupId);
    }
  }
  /**
   * 将临时节点递归地设置到groupId及父节点上
   * @param {string} groupId 群组ID
   * @param {string} tmpNodeId 临时节点ID
   */
  ;

  _proto.setGroupTmpNode = function setGroupTmpNode(groupId, tmpNodeId) {
    var graph = this.graph;
    var graphNodes = graph.get('groupNodes');
    var groups = graph.get('groups');

    if (graphNodes[groupId].indexOf(tmpNodeId) < 0) {
      graphNodes[groupId].push(tmpNodeId);
    } // 获取groupId的父群组


    var parentGroup = groups.filter(function (g) {
      return g.id === groupId;
    });
    var parentId = null;

    if (parentGroup.length > 0) {
      parentId = parentGroup[0].parentId;
    } // 如果存在父群组，则把临时元素也添加到父群组中


    if (parentId) {
      this.setGroupTmpNode(parentId, tmpNodeId);
    }
  }
  /**
   * 收起群组，隐藏群组中的节点及边，群组外部相邻的边都连接到群组上
   *
   * @param {string} id 群组ID
   * @memberof ItemGroup
   */
  ;

  _proto.collapseGroup = function collapseGroup(id) {
    var _this = this;

    var self = this;
    var customGroup = this.getDeletageGroupById(id);
    var nodeGroup = customGroup.nodeGroup,
        groupStyle = customGroup.groupStyle; // 收起群组后的默认样式

    var collapseStyle = this.styles.collapseStyle;
    var graph = this.graph;
    var autoPaint = graph.get('autoPaint');
    graph.setAutoPaint(false);
    var nodesInGroup = graph.get('groupNodes')[id]; // 更新Group的大小

    var keyShape = nodeGroup.get('keyShape');

    var r = collapseStyle.r,
        otherStyle = _objectWithoutPropertiesLoose(collapseStyle, ["r"]);

    for (var style in otherStyle) {
      keyShape.attr(style, otherStyle[style]);
    } // 收起群组时候动画


    keyShape.animate({
      onFrame: function onFrame(ratio) {
        if (ratio === 1) {
          self.setGroupOriginBBox(id, keyShape.getBBox());
        }

        return {
          r: groupStyle.r - ratio * (groupStyle.r - r)
        };
      }
    }, 1000, 'easeCubic');
    var edges = graph.getEdges(); // 获取所有source在群组外，target在群组内的边

    var sourceOutTargetInEdges = edges.filter(function (edge) {
      var model = edge.getModel();
      return !nodesInGroup.includes(model.source) && nodesInGroup.includes(model.target);
    }); // 获取所有source在群组外，target在群组内的边

    var sourceInTargetOutEdges = edges.filter(function (edge) {
      var model = edge.getModel();
      return nodesInGroup.includes(model.source) && !nodesInGroup.includes(model.target);
    }); // 群组中存在source和target其中有一个在群组内，一个在群组外的情况

    if (sourceOutTargetInEdges.length > 0 || sourceInTargetOutEdges.length > 0) {
      var options = {
        groupId: id,
        id: id + "-custom-node",
        x: keyShape.attr('x'),
        y: keyShape.attr('y'),
        style: {
          r: 30
        },
        shape: 'circle'
      };
      var delegateNode = graph.add('node', options);
      delegateNode.set('capture', false);
      delegateNode.hide();
      this.delegateInGroup[id] = {
        delegateNode: delegateNode
      }; // 将临时添加的节点加入到群组中，以便拖动节点时候线跟着拖动
      // nodesInGroup.push(`${id}-custom-node`);

      this.setGroupTmpNode(id, id + "-custom-node");
      this.updateEdgeInGroupLinks(id, sourceOutTargetInEdges, sourceInTargetOutEdges);
    } // 获取群组中节点之间的所有边


    var edgeAllInGroup = edges.filter(function (edge) {
      var model = edge.getModel();
      return nodesInGroup.includes(model.source) && nodesInGroup.includes(model.target);
    }); // 隐藏群组中的所有节点

    nodesInGroup.forEach(function (nodeId) {
      var node = graph.findById(nodeId);
      var model = node.getModel();
      var groupId = model.groupId;

      if (groupId && groupId !== id) {
        // 存在群组，则隐藏
        var currentGroup = _this.getDeletageGroupById(groupId);

        var _nodeGroup = currentGroup.nodeGroup;

        _nodeGroup.hide();
      }

      node.hide();
    });
    edgeAllInGroup.forEach(function (edge) {
      var source = edge.getSource();
      var target = edge.getTarget();

      if (source.isVisible() && target.isVisible()) {
        edge.show();
      } else {
        edge.hide();
      }
    });
    graph.paint();
    graph.setAutoPaint(autoPaint);
  }
  /**
   * 收起群组时生成临时的节点，用于连接群组外的节点
   *
   * @param {string} groupId 群组ID
   * @param {array} sourceOutTargetInEdges 出度的边
   * @param {array} sourceInTargetOutEdges 入度的边
   * @memberof ItemGroup
   */
  ;

  _proto.updateEdgeInGroupLinks = function updateEdgeInGroupLinks(groupId, sourceOutTargetInEdges, sourceInTargetOutEdges) {
    var graph = this.graph; // 更新source在外的节点

    var edgesOuts = {};
    sourceOutTargetInEdges.map(function (edge) {
      var model = edge.getModel();
      var id = model.id,
          target = model.target;
      edgesOuts[id] = target;
      graph.updateItem(edge, {
        target: groupId + "-custom-node"
      });
      return true;
    }); // 更新target在外的节点

    var edgesIn = {};
    sourceInTargetOutEdges.map(function (edge) {
      var model = edge.getModel();
      var id = model.id,
          source = model.source;
      edgesIn[id] = source;
      graph.updateItem(edge, {
        source: groupId + "-custom-node"
      });
      return true;
    }); // 缓存群组groupId下的edge和临时生成的node节点

    this.delegateInGroup[groupId] = merge({
      sourceOutTargetInEdges: sourceOutTargetInEdges,
      sourceInTargetOutEdges: sourceInTargetOutEdges,
      edgesOuts: edgesOuts,
      edgesIn: edgesIn
    }, this.delegateInGroup[groupId]);
  }
  /**
   * 展开群组，恢复群组中的节点及边
   *
   * @param {string} id 群组ID
   * @memberof ItemGroup
   */
  ;

  _proto.expandGroup = function expandGroup(id) {
    var _this2 = this;

    var graph = this.graph;
    var self = this;
    var autoPaint = graph.get('autoPaint');
    graph.setAutoPaint(false); // 显示之前隐藏的节点和群组

    var nodesInGroup = graph.get('groupNodes')[id];

    var _this$getDeletageGrou = this.getDeletageGroupById(id),
        nodeGroup = _this$getDeletageGrou.nodeGroup;

    var _this$calculationGrou3 = this.calculationGroupPosition(nodesInGroup),
        width = _this$calculationGrou3.width,
        height = _this$calculationGrou3.height; // 检测操作的群组中是否包括子群组


    var groups = graph.get('groups');
    var hasSubGroup = !!groups.filter(function (g) {
      return g.parentId === id;
    }).length > 0;
    var r = width > height ? width / 2 : height / 2 + (hasSubGroup ? 20 : 0); // const cx = (width + 2 * x) / 2;
    // const cy = (height + 2 * y) / 2;

    var keyShape = nodeGroup.get('keyShape');
    var defaultStyle = this.styles["default"]; // const styles = merge({}, defaultStyle, { x: cx, y: cy });

    for (var style in defaultStyle) {
      keyShape.attr(style, defaultStyle[style]);
    } // keyShape.attr('r', groupStyle.r + nodesInGroup.length * 10);


    keyShape.animate({
      onFrame: function onFrame(ratio) {
        if (ratio === 1) {
          self.setGroupOriginBBox(id, keyShape.getBBox());
        }

        return {
          r: 30 + ratio * (r + nodesInGroup.length * 10 - 30)
        };
      }
    }, 1000, 'easeCubic'); // this.setGroupOriginBBox(id, keyShape.getBBox());
    // 群组动画一会后再显示节点和边

    setTimeout(function () {
      nodesInGroup.forEach(function (nodeId) {
        var node = graph.findById(nodeId);
        var model = node.getModel();
        var groupId = model.groupId;

        if (groupId && groupId !== id) {
          // 存在群组，则显示
          var currentGroup = _this2.getDeletageGroupById(groupId);

          var _nodeGroup2 = currentGroup.nodeGroup;

          _nodeGroup2.show();

          var hasHidden = _nodeGroup2.get('hasHidden');

          if (!hasHidden) {
            node.show();
          }
        } else {
          node.show();
        }
      });
      var edges = graph.getEdges(); // 获取群组中节点之间的所有边

      var edgeAllInGroup = edges.filter(function (edge) {
        var model = edge.getModel();
        return nodesInGroup.includes(model.source) || nodesInGroup.includes(model.target);
      });
      edgeAllInGroup.forEach(function (edge) {
        var source = edge.getSource();
        var target = edge.getTarget();

        if (source.isVisible() && target.isVisible()) {
          edge.show();
        }
      });
    }, 800);
    var delegates = this.delegateInGroup[id];

    if (delegates) {
      var sourceOutTargetInEdges = delegates.sourceOutTargetInEdges,
          sourceInTargetOutEdges = delegates.sourceInTargetOutEdges,
          edgesOuts = delegates.edgesOuts,
          edgesIn = delegates.edgesIn,
          delegateNode = delegates.delegateNode; // 恢复source在外的节点

      sourceOutTargetInEdges.map(function (edge) {
        var model = edge.getModel();
        var sourceOuts = edgesOuts[model.id];
        graph.updateItem(edge, {
          target: sourceOuts
        });
        return true;
      }); // 恢复target在外的节点

      sourceInTargetOutEdges.map(function (edge) {
        var model = edge.getModel();
        var sourceIn = edgesIn[model.id];
        graph.updateItem(edge, {
          source: sourceIn
        });
        return true;
      }); // 删除群组中的临时节点ID

      var tmpNodeModel = delegateNode.getModel();
      this.deleteTmpNode(id, tmpNodeModel.id);
      graph.remove(delegateNode);
      delete this.delegateInGroup[id];
    }

    graph.setAutoPaint(autoPaint);
    graph.paint();
  };

  _proto.deleteTmpNode = function deleteTmpNode(groupId, tmpNodeId) {
    var graph = this.graph;
    var groups = graph.get('groups');
    var nodesInGroup = graph.get('groupNodes')[groupId];
    var index = nodesInGroup.indexOf(tmpNodeId);
    nodesInGroup.splice(index, 1); // 获取groupId的父群组

    var parentGroup = groups.filter(function (g) {
      return g.id === groupId;
    });
    var parentId = null;

    if (parentGroup.length > 0) {
      parentId = parentGroup[0].parentId;
    } // 如果存在父群组，则把临时元素也添加到父群组中


    if (parentId) {
      this.deleteTmpNode(parentId, tmpNodeId);
    }
  }
  /**
   * 拆分群组
   *
   * @memberof ItemGroup
   */
  ;

  _proto.unGroup = function unGroup() {
    var graph = this.graph;
    var group = graph.get('customGroup');
    var groupChild = group.get('children');
    var autoPaint = graph.get('autoPaint');
    graph.setAutoPaint(false);
    var currentGroup = groupChild.filter(function (child) {
      return child.get('selected');
    });

    if (currentGroup.length > 0) {
      var nodes = graph.getNodes();

      var _loop = function _loop() {
        if (_isArray2) {
          if (_i2 >= _iterator2.length) return "break";
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) return "break";
          _ref2 = _i2.value;
        }

        var current = _ref2;
        var id = current.get('id'); // 删除原群组中node中的groupID

        nodes.forEach(function (node) {
          var model = node.getModel();
          var gId = model.groupId;

          if (!gId) {
            return;
          }

          if (id === gId) {
            delete model.groupId; // 使用没有groupID的数据更新节点

            graph.updateItem(node, model);
          }
        });
        current.destroy();
      };

      for (var _iterator2 = currentGroup, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        var _ret = _loop();

        if (_ret === "break") break;
      }

      graph.setAutoPaint(autoPaint);
      graph.paint();
    }
  };

  _proto.destroy = function destroy() {
    this.graph = null;
    this.styles = {};
    this.customGroup = {};
    this.groupOriginBBox = {};
    this.delegateInGroup = {};
  };

  return CustomGroup;
}();

module.exports = CustomGroup;